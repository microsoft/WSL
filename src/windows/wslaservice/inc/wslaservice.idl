/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wslaservice.idl

Abstract:

    This file contains the COM object definitions used to talk with the WSLa
    service "WslaService"

--*/

import "unknwn.idl";
import "wtypes.idl";

cpp_quote("#ifdef __cplusplus")
cpp_quote("class DECLSPEC_UUID(\"a9b7a1b9-0671-405c-95f1-e0612cb4ce8f\") WSLAUserSession;")
cpp_quote("#endif")

typedef
struct _WSL_VERSION {
    ULONG Major;
    ULONG Minor;
    ULONG Revision;
} WSL_VERSION;

typedef
struct _WSLA_CREATE_PROCESS_OPTIONS { // TODO: Delete once the new API is wired.
    [string] LPCSTR Executable;
    ULONG CommandLineCount;
    [unique, size_is(CommandLineCount)] LPCSTR* CommandLine;
    ULONG EnvironmentCount;
    [unique, size_is(EnvironmentCount)] LPCSTR* Environment;
    [unique] LPCSTR CurrentDirectory;
} WSLA_CREATE_PROCESS_OPTIONS;

typedef struct _WSLA_PROCESS_FD
{
    LONG Fd;
    int Type;
    [string, unique] LPCSTR Path;
} WSLA_PROCESS_FD;

typedef
struct _WSLA_CREATE_PROCESS_RESULT { // TODO: Delete once the new API is wired.
   int Errno;
   int Pid;
} WSLA_CREATE_PROCESS_RESULT;

[
    uuid(7BC4E198-6531-4FA6-ADE2-5EF3D2A04DFE),
    pointer_default(unique),
    object
]
interface ITerminationCallback : IUnknown
{
    HRESULT OnTermination(ULONG Reason, LPCWSTR Details);
};

[
    uuid(5038842F-53DB-4F30-A6D0-A41B02C94AC1),
    pointer_default(unique),
    object
]
interface IProgressCallback : IUnknown
{
    HRESULT OnTermination(ULONG Progress, ULONG Total);
};

// TODO: Delete once the new API is wired.
[
    uuid(82A7ABC8-6B50-43FC-AB96-15FBBE7E8761),
    pointer_default(unique),
    object
]
interface IWSLAVirtualMachine : IUnknown
{
    HRESULT AttachDisk([in] LPCWSTR Path, [in] BOOL ReadOnly, [out] LPSTR* Device, [out] ULONG* Lun);
    HRESULT Mount([in, unique] LPCSTR Source, [in] LPCSTR Target, [in] LPCSTR Type, [in] LPCSTR Options, [in] ULONG Flags); 
    HRESULT CreateLinuxProcess([in] const WSLA_CREATE_PROCESS_OPTIONS* Options, [in] ULONG FdCount, [in, unique, size_is(FdCount)] WSLA_PROCESS_FD* Fds, [out, size_is(FdCount)] ULONG* Handles, [out] WSLA_CREATE_PROCESS_RESULT* Result);
    HRESULT WaitPid([in] LONG Pid, [in] ULONGLONG TimeoutMs,  [out] ULONG* State, [out] int* Code);
    HRESULT Signal([in] LONG Pid, [in] int Signal);
    HRESULT Shutdown([in] ULONGLONG TimeoutMs);
    HRESULT RegisterCallback([in] ITerminationCallback* terminationCallback);
    HRESULT GetDebugShellPipe([out] LPWSTR* pipePath);
    HRESULT MapPort([in] int Family, [in] short WindowsPort, [in] short LinuxPort, [in] BOOL Remove);
    HRESULT Unmount([in] LPCSTR Path);
    HRESULT DetachDisk([in] ULONG Lun);
    HRESULT MountWindowsFolder([in] LPCWSTR WindowsPath, [in] LPCSTR LinuxPath, [in] BOOL ReadOnly);
    HRESULT UnmountWindowsFolder([in] LPCSTR LinuxPath);
    HRESULT MountGpuLibraries([in] LPCSTR LibrariesMountPoint, [in] LPCSTR DriversMountpoint, [in] DWORD Flags);
}

typedef
struct _VIRTUAL_MACHINE_SETTINGS {  // TODO: Delete once the new API is wired.
    LPCWSTR DisplayName;
    ULONGLONG MemoryMb;
    ULONG CpuCount;
    ULONG BootTimeoutMs;
    ULONG DmesgOutput;
    ULONG NetworkingMode;
    BOOL EnableDnsTunneling;
    BOOL EnableDebugShell;
    BOOL EnableEarlyBootDmesg;
    BOOL EnableGPU;
    BOOL EnableDnsTunnelling;
} VIRTUAL_MACHINE_SETTINGS;



struct WSLA_SESSION_SETTINGS {
    LPCWSTR DisplayName;
    LPCWSTR StoragePath;

    // TODO: Termination callback, flags
};


struct WSLA_REGISTRY_AUTHENTICATION_INFORMATION
{
    int Dummy; // Dummy value for the .idl file to compile.
    // TODO: Details TBD.
};


struct WSLA_IMAGE_INFORMATION
{
    LPWSTR Name;
    LPWSTR Hash;
    ULONGLONG Size;
    ULONGLONG DownloadTimestamp;
};

struct WSLA_PROCESS_OPTIONS
{
    LPCSTR Executable;
    [unique] LPCSTR CurrentDirectory;
    [size_is(CommandLineCount)] LPCSTR* CommandLine;
    ULONG CommandLineCount;
    [unique, size_is(EnvironmentCount)] LPCSTR* Environment;
    ULONG EnvironmentCount;
    [unique, size_is(EnvironmentCount)] WSLA_PROCESS_FD *Fds;
    int FdsCount;
};

struct WSLA_VOLUME
{
    LPCSTR WindowsPath;
    LPCSTR LinuxPath;
};

struct WSLA_PORT_MAPPING
{
    USHORT WindowsPort;
    USHORT ContainerPort;
};

struct WSLA_CONTAINER_OPTIONS
{
    LPCWSTR Image;
    LPCWSTR Name;
    struct WSLA_PROCESS_OPTIONS* InitProcessOptions;
    [unique, size_is(VolumesCount)] struct WSLA_VOLUME* Volumes;
    ULONG VolumesCount;
    [unique, size_is(PortsCount)] struct WSLA_PORT_MAPPING* Ports;
    ULONG PortsCount;
    DWORD Flags; // GPU, Privileged, ...
    // TODO: List specific GPU devices.
    ULONGLONG ShmSize;
};

enum WSLA_CONTAINER_STATE
{
    WslaContainerStateInvalid = 0,
    WslaContainerStateCreated = 1,
    WslaContainerStateRunning = 2,
    WslaContainerStateExited = 3,
    WslaContainerStateFailed = 4,
    // TODO: More states might be added to reflect all nerdctl's states.
};

enum WSLA_PROCESS_STATE
{
    WslaProcessStateUnknown = 0,
    WslaProcessStateRunning = 1,
    WslaProcessStateExited = 2,
    WslaProcessStateSignalled = 3
};

struct WSLA_CREATED_PROCESS
{
    int Pid;
    [unique, size_is(FdsCount)] ULONG* Fds;
    ULONG FdsCount;
    ULONG ExitEvent;
};

[
    uuid(EF0661E4-6364-40EA-B433-E2FDF11F3519),
    pointer_default(unique),
    object
]
interface IWSLASession : IUnknown
{
    // Image management.
    HRESULT PullImage([in] LPCWSTR Image, [in, unique] struct WSLA_REGISTRY_AUTHENTICATION_INFORMATION* RegistryInformation, [in, unique] IProgressCallback* ProgressCallback);
    HRESULT ListImages([out, size_is(, *Count)] struct WSLA_IMAGE_INFORMATION** Images, [out] ULONG* Count);
    HRESULT DeleteImage([in] LPCWSTR Image);

    // Container management.
    HRESULT CreateContainer([in] struct WSLA_CONTAINER_OPTIONS* Options);
    HRESULT StartContainer([in] LPCSTR Name);
    HRESULT StopContainer([in] LPCSTR Name);
    HRESULT DeleteContainer([in] LPCSTR Name);
    HRESULT GetContainerState([in] LPCSTR Name, [out] enum WSLA_CONTAINER_STATE* State);

    // Anonymous host port allocation.
    HRESULT AllocateHostPort([in] LPCSTR Name, [in] USHORT ContainerPort, [out] USHORT* AllocatedHostPort);
    HRESULT ReleaseHostPort([in] USHORT HostPort);

    // Process management (nb passing ContainerName = NULL can be used to interact with VM level process for debugging).
    HRESULT CreateContainerProcess([in, unique] LPCSTR ContainerName, [in] struct WSLA_PROCESS_OPTIONS* Options, [out] struct WSLA_CREATED_PROCESS* Process);
    HRESULT GetContainerProcessState([in, unique] LPCWSTR ContainerName, [in] int Pid, [out] enum WSLA_PROCESS_STATE* State, [out] int* Code);
    HRESULT SignalContainerProcess([in, unique] LPCWSTR ContainerName, [in] int Pid, [in] int Signal);

    // Disk management.
    HRESULT FormatVirtualDisk([in] LPCWSTR Path);

     // To be deleted.
    HRESULT GetDisplayName([out] LPWSTR* DisplayName);
}

struct WSLA_SESSION_INFORMATION
{
    ULONG Id;
    DWORD CreatorPid;
    LPSTR DisplayName;
};

[
    uuid(82A7ABC8-6B50-43FC-AB96-15FBBE7E8760),
    pointer_default(unique),
    object
]
interface IWSLAUserSession : IUnknown
{
    HRESULT GetVersion([out] WSL_VERSION* Error);
    HRESULT CreateVirtualMachine([in] const VIRTUAL_MACHINE_SETTINGS* Settings, [out]IWSLAVirtualMachine** VirtualMachine); // TODO: Delete once the new API is wired.

    // Session managment.
    HRESULT CreateSession([in] const struct WSLA_SESSION_SETTINGS* Settings, [out]IWSLASession** Session);
    HRESULT ListSessions([out, size_is(, *SessionsCount)] struct WSLA_SESSION_INFORMATION** Sessions, [out] ULONG* SessionsCount);
    HRESULT OpenSession([in] ULONG Id, [out]IWSLASession** Session);

    // TODO: Do we need 'TerminateSession()' ?
}


