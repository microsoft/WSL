/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wslaservice.idl

Abstract:

    This file contains the COM object definitions used to talk with the WSLa
    service "WslaService"

--*/

import "unknwn.idl";
import "wtypes.idl";

cpp_quote("#ifdef __cplusplus")
cpp_quote("class DECLSPEC_UUID(\"a9b7a1b9-0671-405c-95f1-e0612cb4ce8f\") WSLAUserSession;")
cpp_quote("#endif")

typedef
struct _WSL_VERSION {
    ULONG Major;
    ULONG Minor;
    ULONG Revision;
} WSL_VERSION;

typedef
struct _WSLA_CREATE_PROCESS_OPTIONS { // TODO: Delete once the new API is wired.
    [string] LPCSTR Executable;
    ULONG CommandLineCount;
    [unique, size_is(CommandLineCount)] LPCSTR* CommandLine;
    ULONG EnvironmentCount;
    [unique, size_is(EnvironmentCount)] LPCSTR* Environment;
    [unique] LPCSTR CurrentDirectory;
} WSLA_CREATE_PROCESS_OPTIONS;

typedef struct _WSLA_PROCESS_FD
{
    LONG Fd;
    int Type;
    [string, unique] LPCSTR Path;
} WSLA_PROCESS_FD;

typedef
struct _WSLA_CREATE_PROCESS_RESULT { // TODO: Delete once the new API is wired.
   int Errno;
   int Pid;
} WSLA_CREATE_PROCESS_RESULT;

[
    uuid(7BC4E198-6531-4FA6-ADE2-5EF3D2A04DFE),
    pointer_default(unique),
    object
]
interface ITerminationCallback : IUnknown
{
    HRESULT OnTermination(ULONG Reason, LPCWSTR Details);
};

[
    uuid(5038842F-53DB-4F30-A6D0-A41B02C94AC1),
    pointer_default(unique),
    object
]
interface IProgressCallback : IUnknown
{
    HRESULT OnProgress(ULONG Progress, ULONG Total);
};

// TODO: Delete once the new API is wired.
[
    uuid(82A7ABC8-6B50-43FC-AB96-15FBBE7E8761),
    pointer_default(unique),
    object
]
interface IWSLAVirtualMachine : IUnknown
{
    HRESULT AttachDisk([in] LPCWSTR Path, [in] BOOL ReadOnly, [out] LPSTR* Device, [out] ULONG* Lun);
    HRESULT Mount([in, unique] LPCSTR Source, [in] LPCSTR Target, [in] LPCSTR Type, [in] LPCSTR Options, [in] ULONG Flags); 
    HRESULT CreateLinuxProcess([in] const WSLA_CREATE_PROCESS_OPTIONS* Options, [in] ULONG FdCount, [in, unique, size_is(FdCount)] WSLA_PROCESS_FD* Fds, [out, size_is(FdCount)] ULONG* Handles, [out] WSLA_CREATE_PROCESS_RESULT* Result);
    HRESULT WaitPid([in] LONG Pid, [in] ULONGLONG TimeoutMs,  [out] ULONG* State, [out] int* Code);
    HRESULT Signal([in] LONG Pid, [in] int Signal);
    HRESULT Shutdown([in] ULONGLONG TimeoutMs);
    HRESULT RegisterCallback([in] ITerminationCallback* terminationCallback);
    HRESULT GetDebugShellPipe([out] LPWSTR* pipePath);
    HRESULT MapPort([in] int Family, [in] short WindowsPort, [in] short LinuxPort, [in] BOOL Remove);
    HRESULT Unmount([in] LPCSTR Path);
    HRESULT DetachDisk([in] ULONG Lun);
    HRESULT MountWindowsFolder([in] LPCWSTR WindowsPath, [in] LPCSTR LinuxPath, [in] BOOL ReadOnly);
    HRESULT UnmountWindowsFolder([in] LPCSTR LinuxPath);
    HRESULT MountGpuLibraries([in] LPCSTR LibrariesMountPoint, [in] LPCSTR DriversMountpoint, [in] DWORD Flags);
}

typedef
struct _VIRTUAL_MACHINE_SETTINGS {  // TODO: Delete once the new API is wired.
    LPCWSTR DisplayName;
    ULONGLONG MemoryMb;
    ULONG CpuCount;
    ULONG BootTimeoutMs;
    ULONG DmesgOutput;
    ULONG NetworkingMode;
    BOOL EnableDnsTunneling;
    BOOL EnableDebugShell;
    BOOL EnableEarlyBootDmesg;
    BOOL EnableGPU;
} VIRTUAL_MACHINE_SETTINGS;



struct WSLA_SESSION_SETTINGS {
    LPCWSTR DisplayName;
    LPCWSTR StoragePath;

    // TODO: Termination callback, flags
};


struct WSLA_REGISTRY_AUTHENTICATION_INFORMATION
{
    int Dummy; // Dummy value for the .idl file to compile.
    // TODO: Details TBD.
};


struct WSLA_IMAGE_INFORMATION
{
    LPWSTR Name;
    LPWSTR Hash;
    ULONGLONG Size;
    ULONGLONG DownloadTimestamp;
};

struct WSLA_PROCESS_OPTIONS
{
    LPCSTR Executable;
    [unique] LPCSTR CurrentDirectory;
    [size_is(CommandLineCount)] LPCSTR* CommandLine;
    ULONG CommandLineCount;
    [unique, size_is(EnvironmentCount)] LPCSTR* Environment;
    ULONG EnvironmentCount;
    [unique, size_is(EnvironmentCount)] WSLA_PROCESS_FD *Fds;
    int FdsCount;
};

struct WSLA_VOLUME
{
    LPCSTR HostPath;
    LPCSTR ContainerHostPath;
};

struct WSLA_PORT_MAPPING
{
    USHORT HostPort;
    USHORT ContainerPort;
};

struct WSLA_CONTAINER_OPTIONS
{
    LPCWSTR Image;
    LPCWSTR Name;
    struct WSLA_PROCESS_OPTIONS* InitProcessOptions;
    [unique, size_is(VolumesCount)] struct WSLA_VOLUME* Volumes;
    ULONG VolumesCount;
    [unique, size_is(PortsCount)] struct WSLA_PORT_MAPPING* Ports;
    ULONG PortsCount;
    DWORD Flags; // GPU, Privileged, ...
    // TODO: List specific GPU devices.
    // TODO: Flags on wether the caller wants to override entrypoint, args, or both.
    ULONGLONG ShmSize;
};

enum WSLA_CONTAINER_STATE
{
    WslaContainerStateInvalid = 0,
    WslaContainerStateCreated = 1,
    WslaContainerStateRunning = 2,
    WslaContainerStateExited = 3,
    WslaContainerStateFailed = 4,
    // TODO: More states might be added to reflect all nerdctl's states.
};

enum WSLA_PROCESS_STATE
{
    WslaProcessStateUnknown = 0,
    WslaProcessStateRunning = 1,
    WslaProcessStateExited = 2,
    WslaProcessStateSignalled = 3
};

[
    uuid(1AD163CD-393D-4B33-83A2-8A3F3F23E608),
    pointer_default(unique),
    object
]
interface IWSLAProcess : IUnknown
{
    HRESULT Signal([in] int Signal);
    HRESULT GetExitEvent([out] ULONG* EventHandle);
    HRESULT GetStdHandle([in] ULONG Index, [out] ULONG* Handle);
    HRESULT GetPid([out] int* Pid);
    HRESULT GetState([out] enum WSLA_PROCESS_STATE* State, [out] int* Code);

    // Note: the SDK can offer a convenience Wait() method, but that doesn't need to be part of the service API.
}

[
    uuid(7577FE8D-DE85-471E-B870-11669986F332),
    pointer_default(unique),
    object
]
interface IWSLAContainer : IUnknown
{
    HRESULT Start();
    HRESULT Stop([in] int Signal, [in] ULONG TimeoutMs);
    HRESULT Delete();
    HRESULT GetState([out] enum WSLA_CONTAINER_STATE* State);
    HRESULT GetInitProcess([out] IWSLAProcess** Process);
    HRESULT Exec([in] struct WSLA_PROCESS_OPTIONS* Options, [out] IWSLAProcess** Process);
}

[
    uuid(EF0661E4-6364-40EA-B433-E2FDF11F3519),
    pointer_default(unique),
    object
]
interface IWSLASession : IUnknown
{
    // Image management.
    HRESULT PullImage([in] LPCWSTR Image, [in, unique] struct WSLA_REGISTRY_AUTHENTICATION_INFORMATION* RegistryInformation, [in, unique] IProgressCallback* ProgressCallback);
    HRESULT ListImages([out, size_is(, *Count)] struct WSLA_IMAGE_INFORMATION** Images, [out] ULONG* Count);
    HRESULT DeleteImage([in] LPCWSTR Image);

    // Container management.
    HRESULT CreateContainer([in] struct WSLA_CONTAINER_OPTIONS* Options);
    // TODO: Methods to list & open containers.

    // Anonymous host port allocation (P1).
    HRESULT AllocateHostPort([in] LPCSTR Name, [in] USHORT ContainerPort, [out] USHORT* AllocatedHostPort);
    HRESULT ReleaseHostPort([in] USHORT HostPort);

    // Create a process at the VM level. This is meant for debugging.
    HRESULT CreateRootNamespaceProcess([in] struct WSLA_PROCESS_OPTIONS* Options, [out] IWSLAProcess** Process);

    // TODO: an OpenProcess() method can be added later if needed.

    // Disk management.
    HRESULT FormatVirtualDisk([in] LPCWSTR Path);

     // To be deleted.
    HRESULT GetDisplayName([out] LPWSTR* DisplayName);
    HRESULT GetVirtualMachine([out] IWSLAVirtualMachine **VirtualMachine);
}

struct WSLA_SESSION_INFORMATION
{
    ULONG Id;
    DWORD CreatorPid;
    LPSTR DisplayName;
};

[
    uuid(82A7ABC8-6B50-43FC-AB96-15FBBE7E8760),
    pointer_default(unique),
    object
]
interface IWSLAUserSession : IUnknown
{
    HRESULT GetVersion([out] WSL_VERSION* Error);
    HRESULT CreateVirtualMachine([in] const VIRTUAL_MACHINE_SETTINGS* Settings, [out]IWSLAVirtualMachine** VirtualMachine); // TODO: Delete once the new API is wired.

    // Session managment.
    HRESULT CreateSession([in] const struct WSLA_SESSION_SETTINGS* Settings, [in] const VIRTUAL_MACHINE_SETTINGS* VmSettings, [out]IWSLASession** Session);
    HRESULT ListSessions([out, size_is(, *SessionsCount)] struct WSLA_SESSION_INFORMATION** Sessions, [out] ULONG* SessionsCount);
    HRESULT OpenSession([in] ULONG Id, [out]IWSLASession** Session);

    // TODO: Do we need 'TerminateSession()' ?
}