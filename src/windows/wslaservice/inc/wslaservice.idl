/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wslaservice.idl

Abstract:

    This file contains the COM object definitions used to talk with the WSLa
    service "WslaService"

--*/

import "unknwn.idl";
import "wtypes.idl";

cpp_quote("#ifdef __cplusplus")
cpp_quote("class DECLSPEC_UUID(\"a9b7a1b9-0671-405c-95f1-e0612cb4ce8f\") WSLASessionManager;")
cpp_quote("#endif")

#define WSLA_MAX_CONTAINER_NAME_LENGTH 255
#define WSLA_MAX_IMAGE_NAME_LENGTH 255
#define WSLA_CONTAINER_ID_LENGTH 64

cpp_quote("#define WSLA_MAX_CONTAINER_NAME_LENGTH 255")
cpp_quote("#define WSLA_MAX_IMAGE_NAME_LENGTH 255")
cpp_quote("#define WSLA_CONTAINER_ID_LENGTH 64")

typedef
struct _WSLA_VERSION {
    ULONG Major;
    ULONG Minor;
    ULONG Revision;
} WSLA_VERSION;

typedef enum _WSLAVirtualMachineTerminationReason
{
    WSLAVirtualMachineTerminationReasonUnknown,
    WSLAVirtualMachineTerminationReasonShutdown,
    WSLAVirtualMachineTerminationReasonCrashed,
} WSLAVirtualMachineTerminationReason;

typedef enum _WSLAFD
{
    WSLAFDStdin = 0,
    WSLAFDStdout = 1,
    WSLAFDStderr = 2,
    WSLAFDTty = 3,
} WSLAFD;

typedef enum _WSLASignal
{
    WSLASignalNone = 0,
    WSLASignalSIGHUP = 1,
    WSLASignalSIGINT = 2,
    WSLASignalSIGQUIT = 3,
    WSLASignalSIGILL = 4,
    WSLASignalSIGTRAP = 5,
    WSLASignalSIGABRT = 6,
    WSLASignalSIGIOT = 6, // SIGABRT and SIGIOT are equivalent.
    WSLASignalSIGBUS = 7,
    WSLASignalSIGFPE = 8,
    WSLASignalSIGKILL = 9,
    WSLASignalSIGUSR1 = 10,
    WSLASignalSIGSEGV = 11,
    WSLASignalSIGUSR2 = 12,
    WSLASignalSIGPIPE = 13,
    WSLASignalSIGALRM = 14,
    WSLASignalSIGTERM = 15,
    WSLASignalSIGTKFLT = 16,
    WSLASignalSIGCHLD = 17,
    WSLASignalSIGCONT = 18,
    WSLASignalSIGSTOP = 19,
    WSLASignalSIGTSTP = 20,
    WSLASignalSIGTTIN = 21,
    WSLASignalSIGTTOU = 22,
    WSLASignalSIGURG = 23,
    WSLASignalSIGXCPU = 24,
    WSLASignalSIGXFSZ = 25,
    WSLASignalSIGVTALRM = 26,
    WSLASignalSIGPROF = 27,
    WSLASignalSIGWINCH = 28,
    WSLASignalSIGIO = 29,
    WSLASignalSIGPOLL = 29, // SIGIO and SIGPOLL are equivalent.
    WSLASignalSIGPWR = 30,
    WSLASignalSIGSYS = 31
} WSLASignal;

[
    uuid(7BC4E198-6531-4FA6-ADE2-5EF3D2A04DFE),
    pointer_default(unique),
    object
]
interface ITerminationCallback : IUnknown
{
    HRESULT OnTermination(WSLAVirtualMachineTerminationReason Reason, LPCWSTR Details);
};

[
    uuid(5038842F-53DB-4F30-A6D0-A41B02C94AC1),
    pointer_default(unique),
    object
]
interface IProgressCallback : IUnknown
{
    HRESULT OnProgress(LPCSTR Status, LPCSTR Id, ULONGLONG Current, ULONGLONG Total);
};

struct WSLA_REGISTRY_AUTHENTICATION_INFORMATION
{
    int Dummy; // Dummy value for the .idl file to compile.
    // TODO: Details TBD.
};


struct WSLA_IMAGE_INFORMATION
{
    char Image[WSLA_MAX_IMAGE_NAME_LENGTH + 1];
    char Hash[256];
    ULONGLONG Size;
    ULONGLONG DownloadTimestamp;
};

typedef enum _WSLAProcessFlags
{
    WSLAProcessFlagsNone = 0,
    WSLAProcessFlagsStdin = 1,
    WSLAProcessFlagsTty = 2
} WSLAProcessFlags;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(WSLAProcessFlags);")

typedef struct _WSLAStringArray
{
    [unique, size_is(Count)] LPCSTR* Values;
    ULONG Count;
} WSLAStringArray;

struct WSLA_PROCESS_OPTIONS
{
    [unique] LPCSTR CurrentDirectory;
    [unique] LPCSTR User;
    WSLAStringArray CommandLine;
    WSLAStringArray Environment;
    WSLAProcessFlags Flags;
    ULONG TtyRows; // Only needed when tty fd's are passed.
    ULONG TtyColumns;
};

struct WSLA_VOLUME
{
    LPCWSTR HostPath;
    LPCSTR ContainerPath;
    BOOL ReadOnly;
};

struct WSLA_PORT_MAPPING
{
    USHORT HostPort;
    USHORT ContainerPort;
    int Family;
};

struct WSLA_LABEL
{
    [string] LPCSTR Key;
    [string] LPCSTR Value;
};

struct WSLA_LABEL_INFORMATION
{
    [string] LPSTR Key;
    [string] LPSTR Value;
};

enum WSLA_CONTAINER_NETWORK_TYPE
{
    WSLA_CONTAINER_NETWORK_BRIDGE = 0,
    WSLA_CONTAINER_NETWORK_HOST = 1,
    WSLA_CONTAINER_NETWORK_NONE = 2,
    // WSLA_CONTAINER_NETWORK_CUSTOM = 3 // TODO: Implement when implementing custom networks
};
struct WSLA_CONTAINER_NETWORK
{
    // TODO: Change default to bridge when implemented
    enum WSLA_CONTAINER_NETWORK_TYPE ContainerNetworkType;
    LPCSTR ContainerNetworkName;
};

typedef enum _WSLAContainerFlags
{
    WSLAContainerFlagsNone = 0,
    WSLAContainerFlagsRm = 1, // Delete the container when it exits. TODO: Implement.
    WSLAContainerFlagsGpu = 2, // Enable GPU access. TODO: implement.
    WSLAContainerFlagsInit = 4, // Run the container under an init process.
} WSLAContainerFlags;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(WSLAContainerFlags);")


typedef enum _WSLAContainerStartFlags
{
    WSLAContainerStartFlagsNone = 0,
    WSLAContainerStartFlagsAttach = 1, // Attach stdio handles on start.
} WSLAContainerStartFlags;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(WSLAContainerStartFlags);")

struct WSLA_CONTAINER_OPTIONS
{
    LPCSTR Image;
    [unique] LPCSTR Name;
    WSLAStringArray Entrypoint;
    struct WSLA_PROCESS_OPTIONS InitProcessOptions;
    [unique, size_is(VolumesCount)] struct WSLA_VOLUME* Volumes;
    ULONG VolumesCount;
    [unique, size_is(PortsCount)] struct WSLA_PORT_MAPPING* Ports;
    ULONG PortsCount;
    [unique, size_is(LabelsCount)] const struct WSLA_LABEL* Labels;
    ULONG LabelsCount;
    WSLAContainerFlags Flags;
    WSLASignal StopSignal;
    // TODO: List specific GPU devices.
    [unique] LPCSTR HostName;
    [unique] LPCSTR DomainName;

    ULONGLONG ShmSize;
    struct WSLA_CONTAINER_NETWORK ContainerNetwork;
};

enum WSLA_CONTAINER_STATE
{
    WslaContainerStateInvalid = 0,
    WslaContainerStateCreated = 1,
    WslaContainerStateRunning = 2,
    WslaContainerStateExited = 3,
    WslaContainerStateDeleted = 4,
};

struct WSLA_CONTAINER
{
    char Name[WSLA_MAX_CONTAINER_NAME_LENGTH + 1];
    char Image[WSLA_MAX_IMAGE_NAME_LENGTH + 1];
    enum WSLA_CONTAINER_STATE State;

    // TODO: Add creation timestamp and other fields that the command line tool might want to display.
};

enum WSLA_PROCESS_STATE
{
    WslaProcessStateUnknown = 0,
    WslaProcessStateRunning = 1,
    WslaProcessStateExited = 2,
    WslaProcessStateSignalled = 3
};

[
    uuid(1AD163CD-393D-4B33-83A2-8A3F3F23E608),
    pointer_default(unique),
    object
]
interface IWSLAProcess : IUnknown
{
    HRESULT Signal([in] int Signal);
    HRESULT GetExitEvent([out] ULONG* EventHandle);
    HRESULT GetStdHandle([in] ULONG Index, [out] ULONG* Handle);
    HRESULT GetPid([out] int* Pid);
    HRESULT GetState([out] enum WSLA_PROCESS_STATE* State, [out] int* Code);
    HRESULT ResizeTty([in] ULONG Rows, [in] ULONG Columns);

    // Note: the SDK can offer a convenience Wait() method, but that doesn't need to be part of the service API.
}

typedef enum _WSLANetworkingMode
{
    WSLANetworkingModeNone,
    WSLANetworkingModeNAT,
    WSLANetworkingModeVirtioProxy
} WSLANetworkingMode;

typedef enum _WSLAFeatureFlags
{
    WslaFeatureFlagsNone = 0,
    WslaFeatureFlagsDnsTunneling = 1,
    WslaFeatureFlagsEarlyBootDmesg = 2,
    WslaFeatureFlagsGPU = 4,
    WslaFeatureFlagsVirtioFs = 8,
    WslaFeatureFlagsPmemVhds = 16,
    WslaFeatureFlagsDebug = 32,
} WSLAFeatureFlags;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(WSLAFeatureFlags);")

//
// IWSLAVirtualMachine - Interface representing a single VM instance.
// Operations are scoped to this VM. The VM ID is stored internally,
// so only the holder of this interface can operate on the VM.
//
[
    uuid(B5E2D8F1-9A3C-4E6B-8D1F-7C4A2E9B6D3A),
    pointer_default(unique),
    object
]
interface IWSLAVirtualMachine : IUnknown
{
    // Gets the VM ID.
    HRESULT GetId([out, retval] GUID* VmId);

    // Accepts a connect from mini_init in the VM.
    HRESULT AcceptConnection([out, system_handle(sh_socket)] HANDLE* Socket);

    // Configures networking engine with sockets from the user process.
    // GnsSocket is required; DnsSocket is optional (NULL if DNS tunneling is disabled).
    // The service duplicates the socket handles.
    HRESULT ConfigureNetworking(
        [in, system_handle(sh_socket)] HANDLE GnsSocket,
        [in, system_handle(sh_socket), unique] HANDLE* DnsSocket);

    // Attaches a VHD or VHDX disk to the VM.
    // GrantVmAccess is called by the service before attaching.
    // Returns the SCSI LUN assigned to the disk.
    HRESULT AttachDisk([in] LPCWSTR Path, [in] BOOL ReadOnly, [out, retval] ULONG* Lun);

    // Detaches a previously attached disk from the VM.
    HRESULT DetachDisk([in] ULONG Lun);

    // Adds a filesystem share (Plan9 or VirtioFS) accessible to the VM.
    // Returns an instance GUID that can be used to remove the share.
    HRESULT AddShare([in] LPCWSTR WindowsPath, [in] BOOL ReadOnly, [out, retval] GUID* ShareId);

    // Removes a previously added filesystem share.
    HRESULT RemoveShare([in] REFGUID ShareId);
}

// Settings for IWSLASessionManager::CreateSession - full session configuration
struct WSLA_SESSION_SETTINGS {
    LPCWSTR DisplayName;
    LPCWSTR StoragePath;
    ULONGLONG MaximumStorageSizeMb;
    ULONG CpuCount;
    ULONG MemoryMb;
    ULONG BootTimeoutMs;
    WSLANetworkingMode NetworkingMode;
    [unique] ITerminationCallback* TerminationCallback;
    WSLAFeatureFlags FeatureFlags;
    ULONG DmesgOutput;

    // Below options are used for debugging purposes only.
    [unique] LPCWSTR RootVhdOverride;
    [unique] LPCSTR RootVhdTypeOverride;
};

typedef enum _WSLALogsFlags
{
    WSLALogsFlagsNone = 0,
    WSLALogsFlagsFollow = 1,
    WSLALogsFlagsTimestamps = 2,
} WSLALogsFlags;

typedef char WSLAContainerId[WSLA_CONTAINER_ID_LENGTH + 1] ;

[
    uuid(7577FE8D-DE85-471E-B870-11669986F332),
    pointer_default(unique),
    object
]
interface IWSLAContainer : IUnknown
{
    HRESULT Attach([out] ULONG* StdIn, [out] ULONG* StdOut, [out] ULONG* StdErr);
    HRESULT Stop([in] WSLASignal Signal, [in] LONGLONG TimeoutSeconds);
    HRESULT Start([in] WSLAContainerStartFlags Flags);
    HRESULT Delete(); // TODO: Look into lifetime logic.
    HRESULT GetState([out] enum WSLA_CONTAINER_STATE* State);
    HRESULT GetInitProcess([out] IWSLAProcess** Process);
    HRESULT Exec([in] const struct WSLA_PROCESS_OPTIONS* Options, [out] IWSLAProcess** Process, [out] int* Errno);
    HRESULT Inspect([out] LPSTR* Output);
    HRESULT Logs([in] WSLALogsFlags Flags, [out] ULONG* Stdout, [out] ULONG* Stderr, [in] ULONGLONG Since, [in] ULONGLONG Until, [in] ULONGLONG Tail);
    HRESULT GetId([out, string] WSLAContainerId Id);
    HRESULT GetName([out, string] LPSTR* Name);
    HRESULT GetLabels([out, size_is(, *Count)] struct WSLA_LABEL_INFORMATION** Labels, [out] ULONG* Count);

    // Anonymous host port allocation (P1).
    //HRESULT AllocateHostPort([in] LPCSTR Name, [in] USHORT ContainerPort, [out] USHORT* AllocatedHostPort);
    //HRESULT ReleaseHostPort([in] USHORT HostPort);
}

typedef enum _WSLADeletedImageType
{
    WSLADeletedImageTypeDeleted = 0,
    WSLADeletedImageTypeUntagged = 1
} WSLADeletedImageType;

struct WSLA_DELETED_IMAGE_INFORMATION
{
    char Image[WSLA_MAX_IMAGE_NAME_LENGTH + 1];
    WSLADeletedImageType Type;
};

struct WSLA_DELETE_IMAGE_OPTIONS
{
    LPCSTR Image; // Image can be ID or Repo:Tag.
    BOOL Force;
    BOOL NoPrune;
    // TODO: Platforms: a json array of OCI platform strings.
};

typedef enum _WSLASessionState
{
    WSLASessionStateRunning = 0,
    WSLASessionStateTerminated = 1
} WSLASessionState;

[
    uuid(EF0661E4-6364-40EA-B433-E2FDF11F3519),
    pointer_default(unique),
    object
]
interface IWSLASession : IUnknown
{
    HRESULT GetId([out] ULONG* Id);
    HRESULT GetState([out] WSLASessionState* State);

    // Image management.
    HRESULT PullImage([in] LPCSTR ImageUri, [in, unique] const struct WSLA_REGISTRY_AUTHENTICATION_INFORMATION* RegistryAuthenticationInformation, [in, unique] IProgressCallback* ProgressCallback);
    HRESULT LoadImage([in] ULONG ImageHandle, [in, unique] IProgressCallback* ProgressCallback, [in] ULONGLONG ContentLength);
    HRESULT ImportImage([in] ULONG ImageHandle, [in] LPCSTR ImageName, [in, unique] IProgressCallback* ProgressCallback, [in] ULONGLONG ContentLength);
    HRESULT SaveImage([in] ULONG OutputHandle, [in] LPCSTR ImageNameOrID, [in, unique] IProgressCallback * ProgressCallback);
    HRESULT ListImages([out, size_is(, *Count)] struct WSLA_IMAGE_INFORMATION** Images, [out] ULONG* Count);
    HRESULT DeleteImage([in] const struct WSLA_DELETE_IMAGE_OPTIONS* Options, [out, size_is(, *Count)] struct WSLA_DELETED_IMAGE_INFORMATION** DeletedImages, [out] ULONG* Count);

    // Container management.
    HRESULT CreateContainer([in] const struct WSLA_CONTAINER_OPTIONS* Options, [out] IWSLAContainer** Container);
    HRESULT OpenContainer([in] LPCSTR Id, [out] IWSLAContainer** Container);
    HRESULT ListContainers([out, size_is(, *Count)] struct WSLA_CONTAINER** Images, [out] ULONG* Count);
    HRESULT ExportContainer([in] ULONG OutputHandle, [in] LPCSTR ContainerID, [in, unique] IProgressCallback * ProgressCallback);

    // Create a process at the VM level. This is meant for debugging.
    HRESULT CreateRootNamespaceProcess([in] LPCSTR Executable, [in] const struct WSLA_PROCESS_OPTIONS* Options, [out] IWSLAProcess** Process, [out] int* Errno);

    // TODO: an OpenProcess() method can be added later if needed.

    // Disk management.
    HRESULT FormatVirtualDisk([in] LPCWSTR Path);

    // Terminate the VM and containers.
    HRESULT Terminate();

    // Used only for testing. TODO: Think about moving them to a dedicated testing-only interface.
    HRESULT MountWindowsFolder([in] LPCWSTR WindowsPath, [in] LPCSTR LinuxPath, [in] BOOL ReadOnly);
    HRESULT UnmountWindowsFolder([in] LPCSTR LinuxPath);
    HRESULT MapVmPort([in] int Family, [in] short WindowsPort, [in] short LinuxPort);
    HRESULT UnmapVmPort([in] int Family, [in] short WindowsPort, [in] short LinuxPort);

    // Session initialization - called by SYSTEM service after launching per-user process.
    // Returns a handle to this COM server process (used to add to job object).
    HRESULT GetProcessHandle([out, system_handle(sh_process)] HANDLE* ProcessHandle);

    // Initializes the session with a pre-created VM.
    HRESULT Initialize(
        [in] const struct WSLA_SESSION_INIT_SETTINGS* Settings,
        [in] IWSLAVirtualMachine* Vm);

}

//
// IWSLASessionReference - Weak reference to a session held by the SYSTEM service.
// Stored in per-user process, allows service to check liveness and terminate sessions.
// Session metadata (ID, name, etc.) is stored service-side in SessionEntry.
//
[
    uuid(B3A72F48-9D15-4E8A-A621-7C3E84F09B52),
    pointer_default(unique),
    object
]
interface IWSLASessionReference : IUnknown
{
    // Try to open the session. Fails if session was released or terminated.
    // Returns S_OK and a valid session if still alive.
    HRESULT OpenSession([out] IWSLASession** Session);

    // Terminate the session if still alive.
    HRESULT Terminate();
}

//
// IWSLASessionFactory - Creates sessions in the per-user COM server process.
// Called by the SYSTEM service via CoCreateInstanceAsUser.
//
[
    uuid(C4E8F291-3B5D-4A7C-9E12-8F6A4D2B7C91),
    pointer_default(unique),
    object
]
interface IWSLASessionFactory : IUnknown
{
    // Creates a new session and returns both the session interface and a service reference.
    HRESULT CreateSession(
        [in] const struct WSLA_SESSION_INIT_SETTINGS* Settings,
        [in] IWSLAVirtualMachine* Vm,
        [out] IWSLASession** Session,
        [out] IWSLASessionReference** ServiceRef);

    // Gets the process handle for adding to job object.
    HRESULT GetProcessHandle([out, system_handle(sh_process)] HANDLE* ProcessHandle);
}

struct WSLA_SESSION_INFORMATION
{
    ULONG SessionId;
    DWORD CreatorPid;
    wchar_t DisplayName[256];
    wchar_t Sid[256 + 1]; // MAX_SID_SIZE = 256
};

// Settings for IWSLASession::Initialize - passed from service to per-user process
struct WSLA_SESSION_INIT_SETTINGS {
    ULONG SessionId;
    ULONG CreatorPid;
    LPCWSTR DisplayName;
    LPCWSTR StoragePath;
    ULONGLONG MaximumStorageSizeMb;
    ULONG BootTimeoutMs;
    WSLANetworkingMode NetworkingMode;
    WSLAFeatureFlags FeatureFlags;
    [unique] LPCSTR RootVhdTypeOverride;
};

typedef enum _WSLASessionFlags
{
    WSLASessionFlagsNone = 0,
    WSLASessionFlagsPersistent = 1, // Session remains active after its COM reference is released.
    WSLASessionFlagsOpenExisting = 2, // Open an existing session if the name is in use.
} WSLASessionFlags;

[
    uuid(82A7ABC8-6B50-43FC-AB96-15FBBE7E8760),
    pointer_default(unique),
    object
]
interface IWSLASessionManager : IUnknown
{
    HRESULT GetVersion([out] WSLA_VERSION* Version);

    // Session management.
    HRESULT CreateSession([in] const struct WSLA_SESSION_SETTINGS* Settings, WSLASessionFlags Flags, [out] IWSLASession** Session);
    HRESULT ListSessions([out, size_is(, *SessionsCount)] struct WSLA_SESSION_INFORMATION** Sessions, [out] ULONG* SessionsCount);
    HRESULT OpenSession([in] ULONG Id, [out] IWSLASession** Session);
    HRESULT OpenSessionByName([in] LPCWSTR DisplayName, [out] IWSLASession** Session);
}

cpp_quote("#define WSLA_E_BASE (0x0600)")
cpp_quote("#define WSLA_E_IMAGE_NOT_FOUND MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, WSLA_E_BASE + 1) /* 0x80040601 */")
cpp_quote("#define WSLA_E_CONTAINER_PREFIX_AMBIGUOUS MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, WSLA_E_BASE + 2) /* 0x80040602 */")
cpp_quote("#define WSLA_E_CONTAINER_NOT_FOUND MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, WSLA_E_BASE + 3) /* 0x80040603 */")